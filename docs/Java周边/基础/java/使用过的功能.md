# 使用过的功能

## 动态生成类

<div class="gpt_html_div">
    <div id="scrollRef" class="h-full overflow-hidden overflow-y-auto">
        <div id="image-wrapper" class="w-full max-w-screen-xl m-auto dark:bg-[#101014] p-4">
            <!--问-->
            <div class="flex w-full mb-6 overflow-hidden flex-row-reverse"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 ml-2"><span class="n-avatar" style="--n-font-size:14px; --n-border:none; --n-border-radius:3px; --n-color:rgba(204, 204, 204, 1); --n-color-modal:rgba(204, 204, 204, 1); --n-color-popover:rgba(204, 204, 204, 1); --n-bezier:cubic-bezier(0.4, 0, 0.2, 1); --n-merged-size:var(--n-avatar-size-override, 34px);"><img loading="eager" src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png" data-image-src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png"><!----></span></div><div class="overflow-hidden text-sm items-end"><p class="text-xs text-[#b4bbc4] text-right">2023/8/1 17:10:25</p><div class="flex items-end gap-1 mt-2 flex-row-reverse"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#d2f9d1] dark:bg-[#a1dc95]"><div class="leading-relaxed break-words"><div class="whitespace-pre-wrap">CtClass类的应用场景</div></div></div><div class="flex flex-col"><!----><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
            <!--答-->
            <div class="flex w-full mb-6 overflow-hidden"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 mr-2"><span class="text-[28px] dark:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" aria-hidden="true" width="1em" height="1em"><path d="M29.71,13.09A8.09,8.09,0,0,0,20.34,2.68a8.08,8.08,0,0,0-13.7,2.9A8.08,8.08,0,0,0,2.3,18.9,8,8,0,0,0,3,25.45a8.08,8.08,0,0,0,8.69,3.87,8,8,0,0,0,6,2.68,8.09,8.09,0,0,0,7.7-5.61,8,8,0,0,0,5.33-3.86A8.09,8.09,0,0,0,29.71,13.09Zm-12,16.82a6,6,0,0,1-3.84-1.39l.19-.11,6.37-3.68a1,1,0,0,0,.53-.91v-9l2.69,1.56a.08.08,0,0,1,.05.07v7.44A6,6,0,0,1,17.68,29.91ZM4.8,24.41a6,6,0,0,1-.71-4l.19.11,6.37,3.68a1,1,0,0,0,1,0l7.79-4.49V22.8a.09.09,0,0,1,0,.08L13,26.6A6,6,0,0,1,4.8,24.41ZM3.12,10.53A6,6,0,0,1,6.28,7.9v7.57a1,1,0,0,0,.51.9l7.75,4.47L11.85,22.4a.14.14,0,0,1-.09,0L5.32,18.68a6,6,0,0,1-2.2-8.18Zm22.13,5.14-7.78-4.52L20.16,9.6a.08.08,0,0,1,.09,0l6.44,3.72a6,6,0,0,1-.9,10.81V16.56A1.06,1.06,0,0,0,25.25,15.67Zm2.68-4-.19-.12-6.36-3.7a1,1,0,0,0-1.05,0l-7.78,4.49V9.2a.09.09,0,0,1,0-.09L19,5.4a6,6,0,0,1,8.91,6.21ZM11.08,17.15,8.38,15.6a.14.14,0,0,1-.05-.08V8.1a6,6,0,0,1,9.84-4.61L18,3.6,11.61,7.28a1,1,0,0,0-.53.91ZM12.54,14,16,12l3.47,2v4L16,20l-3.47-2Z" fill="currentColor"></path></svg></span></div><div class="overflow-hidden text-sm items-start"><p class="text-xs text-[#b4bbc4] text-left">2023/8/1 17:10:50</p><div class="flex items-end gap-1 mt-2 flex-row"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#f4f6f8] dark:bg-[#1e1e20]"><div class="leading-relaxed break-words"><div class="markdown-body"><p>CtClass类是Javassist库提供的一个核心类，用于表示已加载的类或待创建的新类。它提供了一系列方法来操作和修改类的结构、属性和方法。</p>
                <p>CtClass类的应用场景主要包括以下几个方面：</p>
                <ol>
                <li>
                <p>动态生成类：使用CtClass类可以在运行时动态生成新的类。这对于某些特定的场景非常有用，例如在框架或插件系统中需要动态创建和加载类。通过CtClass，可以添加字段、方法，修改类的继承关系，生成新的字节码，并在运行时加载和使用这些类。</p>
                </li>
                <li>
                <p>字节码操作和修改：CtClass提供的方法可以直接操作类的字节码。通过CtClass，可以获取和修改类的字段、方法、构造函数、注解等信息。可以新增、删除或修改现有的方法和字段，修改方法体的字节码指令，实现对类的字节码级别的定制化操作。</p>
                </li>
                <li>
                <p>代码生成和模板扩展：CtClass类可以结合反射和代码生成技术，实现基于模板的代码扩展和自动生成。通过CtClass，可以根据规则和模板生成类的骨架，然后在此基础上生成具体的代码，填充字段、方法、注解等细节，最后动态加载和使用生成的类。</p>
                </li>
                <li>
                <p>类型分析和元数据提取：CtClass提供了方法来分析类的结构和属性，例如获取类的父类、接口、注解，获取字段和方法的信息，以及访问方法的参数和返回类型等。这些功能对于一些工具和框架来说非常有用，可以基于类的元数据进行各种类型的分析、检查或处理。</p>
                </li>
                </ol>
                <p>总之，CtClass类主要用于在运行时动态生成和修改类的结构和字节码，以实现对类级别的定制化操作、代码生成和扩展。它为开发者提供了更灵活的方式来操作类和字节码，适用于一些特定的场景和需求，如动态代理、AOP框架、ORM工具、代码生成器等。</p>
                </div></div></div><div class="flex flex-col"><button class="mb-2 transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-300"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795Z"></path></svg></button><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
        </div>
    </div>
</div>

::: details 用例
```java
import javassist.*;
import javassist.bytecode.DuplicateMemberException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.*;

/**
 * 虚拟实体构建类
 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
 * 创建时间: 2021年11月23日 16:19:48
 * @author 99013
 */
public class Lingdu {

	private static final Logger log = LoggerFactory.getLogger(Lingdu.class);

	/**
	 * 虚拟实体类编译路径(初始化路径,是从类池里面获取的)
	 */
	private final String className = "com.lingdu.dimensiondoor.utils.Ling"+UUID.randomUUID();
	/**
	 * 目标类
	 */
	private Class<?> clazz;
	public Class<?> getClazz(){
		return clazz;
	}
	/**
	 * 可编辑目标类
	 */
	private CtClass cc;

	/**
	 * 入参信息<参数名,参数值>
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年03月16日 17:52:00
	 */
	Map<String, Object> param;

	public Map<String, Object> getParam() {
		return param;
	}
	public void setParam(Map<String, Object> param){
		this.param = param;
	}

	public Lingdu(){
	}
	public Lingdu(List<String> names){
		if(names!=null){
			param=new HashMap<>((int)(names.size()/0.75+1));
			for (String name : names) {
				param.put(name,null);
			}
		}
	}
	public Lingdu(Map<String, Object> param){
		this.param = param;
	}

	/**
	 * 虚拟实体封装
	 * @return 返回封装好的实体集合
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月18日 09:52:23
	 */
	public Object sviVirtualEntityEncapsulation() {
		try {
			/*初始化虚拟实体*/
			initializesVirtualEntity();
			/*封装数据*/
			return encapsulateData();
		} catch (Exception e) {
			log.error("初始化虚拟实体/虚拟实体封装出错!",e);
		}
		return null;
	}

	/**
	 * 初始化虚拟实体
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月18日 09:37:44
	 */
	public void initializesVirtualEntity() throws Exception {
		// 初始化可编辑目标类
		getMyClass();
		for (String name : param.keySet()) {
			try {
				changeClass(name);
				// 字段重复异常
			} catch (DuplicateMemberException e) {
				log.error("字段重复!",e);
			}
		}
		/*重新加载修改后的类*/
		reload(cc);
	}

	/**
	 * 创建属性及get\set方法
	 * @param fieldName 属性名
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月17日 17:19:52
	 */
	private void changeClass(String fieldName) throws CannotCompileException, NotFoundException, IOException {
		String type = "Object";
		//为cTclass对象添加一个属性
		cc.addField(CtField.make("private "+type+" " + fieldName + ";", cc));
		createMethod("public void set" + fieldName + "("+type+" " + fieldName + "){this." + fieldName + " = " + fieldName + ";}");
		createMethod("public "+type+" get" + fieldName + "(){return this." + fieldName + ";}");

	}

	/**
	 * 封装数据
	 * @return 返回封装好的实体集合
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月18日 09:38:11
	 */
	private Object encapsulateData() throws Exception {
		Object o = clazz.newInstance();
		for (String s : param.keySet()) {
			clazz.getDeclaredMethod("set" + s, Object.class).invoke(o, param.get(s));
		}
		clazz=null;
		/*类重置*/
//		resetClass();
		return o;
	}

	/**
	 * 获取自定义虚拟类
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月17日 16:50:55
	 */
	private void getMyClass() throws NotFoundException {
		// 类池
		/*永远获取子级类池,这样类池就不会因为随着方法的调用越来越多*/
		ClassPool pool = MyClassLoader.getClassPool();
		try {
			// 创建虚拟实体类
			cc = pool.makeClass(className);
		} catch (Exception e) {
			// 已经存在了
			cc = pool.get(className);
		}
		cc.defrost();// 解冻
	}

	/**
	 * 重新加载修改后的类
	 * @param cc 修改后的类
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月17日 17:00:00
	 */
	private void reload(CtClass cc) throws IOException, CannotCompileException {
		byte[] bytes = cc.toBytecode();
		// 使用自定义的ClassLoader
		MyClassLoader cl = new MyClassLoader();
		// 加载我们生成的 Ling 类
		clazz = cl.defineClass(className, bytes);
	}

	/*
	 * 重置类 之前由于虚拟类编译路径相同,考虑到相同实体类字段越用越多的问题所以在创建使用完
	 * 调用本方法清空所有成员变量以及相应的get/set方法.
	 * 虚拟类2.0在类编译路径后面加上了UUID唯一标识,就不存在字段越用越多的问题.所以可舍弃本方
	 * 法清空字段.猜测接口调用过于频繁导致的mybatis底层偶尔获取不到字段信息于此有关,所以该方
	 * 法被弃用
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月17日 16:29:04
	 */
//	@Deprecated
//	public void resetClass() throws Exception {
//		// 初始化可编辑目标类
//		getMyClass();
//		CtMethod[] methods = cc.getDeclaredMethods();
//		for (CtMethod method : methods) {
//			/*删除本类所有方法*/
//			cc.removeMethod(method);
//		}
//		CtField[] fields = cc.getDeclaredFields();
//		for (CtField field : fields) {
//			/*删除本类所有变量*/
//			cc.removeField(field);
//		}
//		/*重新加载修改后的类*/
//		reload(cc);
//	}


	/**
	 * 单独创建方法
	 * @param m 具体方法结构
	 * @return java.lang.Class<?>
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年02月17日 10:50:05
	 */
	public Class<?> createMethod(String m) throws NotFoundException, CannotCompileException, IOException {
		boolean b=false;
		if(cc==null){
			b=true;
			// 初始化可编辑目标类
			getMyClass();
		}
		cc.addMethod(CtMethod.make(m, cc));
		if(b){
			reload(cc);
			return clazz;
		}else {
			return null;
		}
	}

}

```
:::

## 自定义类加载器

<div  class="gpt_html_div">
    <div id="scrollRef" class="h-full overflow-hidden overflow-y-auto">
        <div id="image-wrapper" class="w-full max-w-screen-xl m-auto dark:bg-[#101014] p-4">
            <!--问-->
            <div class="flex w-full mb-6 overflow-hidden flex-row-reverse"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 ml-2"><span class="n-avatar" style="--n-font-size:14px; --n-border:none; --n-border-radius:3px; --n-color:rgba(204, 204, 204, 1); --n-color-modal:rgba(204, 204, 204, 1); --n-color-popover:rgba(204, 204, 204, 1); --n-bezier:cubic-bezier(0.4, 0, 0.2, 1); --n-merged-size:var(--n-avatar-size-override, 34px);"><img loading="eager" src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png" data-image-src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png"><!----></span></div><div class="overflow-hidden text-sm items-end"><p class="text-xs text-[#b4bbc4] text-right">2023/8/2 09:53:01</p><div class="flex items-end gap-1 mt-2 flex-row-reverse"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#d2f9d1] dark:bg-[#a1dc95]"><div class="leading-relaxed break-words"><div class="whitespace-pre-wrap">自定义类加载器</div></div></div><div class="flex flex-col"><!----><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
            <!--答-->
            <div class="flex w-full mb-6 overflow-hidden"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 mr-2"><span class="text-[28px] dark:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" aria-hidden="true" width="1em" height="1em"><path d="M29.71,13.09A8.09,8.09,0,0,0,20.34,2.68a8.08,8.08,0,0,0-13.7,2.9A8.08,8.08,0,0,0,2.3,18.9,8,8,0,0,0,3,25.45a8.08,8.08,0,0,0,8.69,3.87,8,8,0,0,0,6,2.68,8.09,8.09,0,0,0,7.7-5.61,8,8,0,0,0,5.33-3.86A8.09,8.09,0,0,0,29.71,13.09Zm-12,16.82a6,6,0,0,1-3.84-1.39l.19-.11,6.37-3.68a1,1,0,0,0,.53-.91v-9l2.69,1.56a.08.08,0,0,1,.05.07v7.44A6,6,0,0,1,17.68,29.91ZM4.8,24.41a6,6,0,0,1-.71-4l.19.11,6.37,3.68a1,1,0,0,0,1,0l7.79-4.49V22.8a.09.09,0,0,1,0,.08L13,26.6A6,6,0,0,1,4.8,24.41ZM3.12,10.53A6,6,0,0,1,6.28,7.9v7.57a1,1,0,0,0,.51.9l7.75,4.47L11.85,22.4a.14.14,0,0,1-.09,0L5.32,18.68a6,6,0,0,1-2.2-8.18Zm22.13,5.14-7.78-4.52L20.16,9.6a.08.08,0,0,1,.09,0l6.44,3.72a6,6,0,0,1-.9,10.81V16.56A1.06,1.06,0,0,0,25.25,15.67Zm2.68-4-.19-.12-6.36-3.7a1,1,0,0,0-1.05,0l-7.78,4.49V9.2a.09.09,0,0,1,0-.09L19,5.4a6,6,0,0,1,8.91,6.21ZM11.08,17.15,8.38,15.6a.14.14,0,0,1-.05-.08V8.1a6,6,0,0,1,9.84-4.61L18,3.6,11.61,7.28a1,1,0,0,0-.53.91ZM12.54,14,16,12l3.47,2v4L16,20l-3.47-2Z" fill="currentColor"></path></svg></span></div><div class="overflow-hidden text-sm items-start"><p class="text-xs text-[#b4bbc4] text-left">2023/8/2 09:53:19</p><div class="flex items-end gap-1 mt-2 flex-row"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#f4f6f8] dark:bg-[#1e1e20]"><div class="leading-relaxed break-words"><div class="markdown-body"><p>自定义类加载器是Java中的一个特性，它允许开发者根据自己的需求定义自己的类加载过程。通过自定义类加载器，我们可以实现一些灵活的类加载逻辑，例如从非标准的位置加载类文件、动态生成类等。</p>
<p>要创建自定义类加载器，需要继承<code>java.lang.ClassLoader</code>类，并覆盖其中的一些方法。下面是一个简单的示例：</p>

```java
public class CustomClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        // 自定义类加载逻辑，根据类名加载对应的字节码，并通过defineClass方法转换为Class对象
        byte[] classBytes = loadClassBytes(name);
        return defineClass(name, classBytes, 0, classBytes.length);
    }
    private byte[] loadClassBytes(String className) {
        // 加载类字节码的具体实现，可以读取文件、从数据库获取等
        // 这里只是简单示例，假设从文件系统加载
        String fileName = className.replace('.', '/') + ".class";
        try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream(fileName)) {
            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
            int nextValue;
            while ((nextValue = inputStream.read()) != -1) {
                byteStream.write(nextValue);
            }
            return byteStream.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

<p>上述代码中，<code>findClass</code>方法是自定义类加载器的核心方法，负责根据类名加载对应的字节码并转换为Class对象。<code>loadClassBytes</code>方法是一个具体的实现，可以根据自己的需求从不同的来源加载类的字节码。</p>
<p>使用自定义类加载器时，可以通过调用<code>loadClass</code>方法来加载指定名称的类，如下所示：</p>

```java
public class Main {
    public static void main(String[] args) throws ClassNotFoundException {
        CustomClassLoader classLoader = new CustomClassLoader();
        Class<?> clazz = classLoader.loadClass("com.example.MyClass");
        // 使用加载的类进行操作
    }
}
```

<p>需要注意的是，在使用自定义类加载器时，要确保类加载器的双亲委派机制符合预期。根据需要，可以选择覆盖其他相关方法以满足具体的要求。</p>
<p>自定义类加载器在某些特定场景下非常有用，例如实现类似热部署、插件化等功能。但是在普通应用中，一般情况下都可以使用默认的系统类加载器（或其子类）来满足需求。</p>
</div></div></div><div class="flex flex-col"><button class="mb-2 transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-300"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795Z"></path></svg></button><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
        </div>
    </div>
</div>

::: details 用例
```java

import javassist.ClassPool;

/**
 * @author 99013
 * @ClassName MyClassLoader
 * @Description 自定义类加载器
 * 作者：99013
 * 创建时间：2022年02月17日 15:36:54
 * @Version 1.0
 **/
public class MyClassLoader extends ClassLoader {

	// 类池
	private static ClassPool pool;
	/**
	 * 利用子类池覆盖默认类池,从而防止ClassPool中类越来越多的情况
	 * @return javassist.ClassPool
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年05月24日 14:33:11
	 */
	public static ClassPool getClassPool(){
		return new ClassPool(getPool());
	}
	/**
	 * 初始默认类池
	 * @return javassist.ClassPool
	 * <br><br><b>作者: 990130556 <a class=b href="https://blog.csdn.net/lingdu_dou">lingdu</a></b><br>
	 * 创建时间: 2022年05月24日 14:35:01
	 */
	private static ClassPool getPool(){
		if(pool==null){
			pool = ClassPool.getDefault();
		}
		return pool;
	}

	public Class<?> defineClass(String name, byte[] b) {
		// ClassLoader是个抽象类，而ClassLoader.defineClass 方法是protected的
		// 所以我们需要定义一个子类将这个方法暴露出来
		return super.defineClass(name, b, 0, b.length);
	}

	@Override
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		// 根据类的全类名进行加锁操作，也就是保证了线程安全
		synchronized (getClassLoadingLock(name)) {
			Class<?> klass = findLoadedClass(name);
			// 到已经加载的缓存中查看是否已经被加载了如果是则直接返回，如果没有就需要进行加载
			if (klass == null) {
				// 如果缓存中没有，则表示这个类是第一次被加载，对于类进行判断操作
				if (name.startsWith("java.") || name.startsWith("javax.")) {
					try {
						klass = getSystemClassLoader().loadClass(name);
					} catch (Exception e) {
						throw e;
					}
					// 如果不满足要求则表示使用自定义的类加载器进行加载操作。
				} else {
					try {
						klass = this.findClass(name);
					} catch (Exception ignored) {
					}
					// 如果自定义加载器没有完成则需要交给父类加载器去进行加载操作
					if (klass == null) {
						if (getParent() != null) {
							klass = getParent().loadClass(name);
						} else {
							klass = getSystemClassLoader().loadClass(name);
						}
					}
				}
			}
			// 如果加载不成功的话就抛出异常。
			if (null == klass) {
				throw new ClassNotFoundException("The class " + name + " not found.");
			}
			if (resolve) {
				resolveClass(klass);
			}
			return klass;
		}
	}
}

```
:::

## 自定义线程池

<div  class="gpt_html_div">
    <div id="scrollRef" class="h-full overflow-hidden overflow-y-auto">
        <div id="image-wrapper" class="w-full max-w-screen-xl m-auto dark:bg-[#101014] p-4">
            <!--问-->
            <div class="flex w-full mb-6 overflow-hidden flex-row-reverse"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 ml-2"><span class="n-avatar" style="--n-font-size:14px; --n-border:none; --n-border-radius:3px; --n-color:rgba(204, 204, 204, 1); --n-color-modal:rgba(204, 204, 204, 1); --n-color-popover:rgba(204, 204, 204, 1); --n-bezier:cubic-bezier(0.4, 0, 0.2, 1); --n-merged-size:var(--n-avatar-size-override, 34px);"><img loading="eager" src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png" data-image-src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png"><!----></span></div><div class="overflow-hidden text-sm items-end"><p class="text-xs text-[#b4bbc4] text-right">2023/8/2 11:06:58</p><div class="flex items-end gap-1 mt-2 flex-row-reverse"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#d2f9d1] dark:bg-[#a1dc95]"><div class="leading-relaxed break-words"><div class="whitespace-pre-wrap">自定义线程池</div></div></div><div class="flex flex-col"><!----><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
            <!--答-->
            <div class="flex w-full mb-6 overflow-hidden"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 mr-2"><span class="text-[28px] dark:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" aria-hidden="true" width="1em" height="1em"><path d="M29.71,13.09A8.09,8.09,0,0,0,20.34,2.68a8.08,8.08,0,0,0-13.7,2.9A8.08,8.08,0,0,0,2.3,18.9,8,8,0,0,0,3,25.45a8.08,8.08,0,0,0,8.69,3.87,8,8,0,0,0,6,2.68,8.09,8.09,0,0,0,7.7-5.61,8,8,0,0,0,5.33-3.86A8.09,8.09,0,0,0,29.71,13.09Zm-12,16.82a6,6,0,0,1-3.84-1.39l.19-.11,6.37-3.68a1,1,0,0,0,.53-.91v-9l2.69,1.56a.08.08,0,0,1,.05.07v7.44A6,6,0,0,1,17.68,29.91ZM4.8,24.41a6,6,0,0,1-.71-4l.19.11,6.37,3.68a1,1,0,0,0,1,0l7.79-4.49V22.8a.09.09,0,0,1,0,.08L13,26.6A6,6,0,0,1,4.8,24.41ZM3.12,10.53A6,6,0,0,1,6.28,7.9v7.57a1,1,0,0,0,.51.9l7.75,4.47L11.85,22.4a.14.14,0,0,1-.09,0L5.32,18.68a6,6,0,0,1-2.2-8.18Zm22.13,5.14-7.78-4.52L20.16,9.6a.08.08,0,0,1,.09,0l6.44,3.72a6,6,0,0,1-.9,10.81V16.56A1.06,1.06,0,0,0,25.25,15.67Zm2.68-4-.19-.12-6.36-3.7a1,1,0,0,0-1.05,0l-7.78,4.49V9.2a.09.09,0,0,1,0-.09L19,5.4a6,6,0,0,1,8.91,6.21ZM11.08,17.15,8.38,15.6a.14.14,0,0,1-.05-.08V8.1a6,6,0,0,1,9.84-4.61L18,3.6,11.61,7.28a1,1,0,0,0-.53.91ZM12.54,14,16,12l3.47,2v4L16,20l-3.47-2Z" fill="currentColor"></path></svg></span></div><div class="overflow-hidden text-sm items-start"><p class="text-xs text-[#b4bbc4] text-left">2023/8/2 11:07:14</p><div class="flex items-end gap-1 mt-2 flex-row"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#f4f6f8] dark:bg-[#1e1e20]"><div class="leading-relaxed break-words"><div class="markdown-body"><p>要自定义线程池，可以使用Java的<code>ThreadPoolExecutor</code>类作为基础，并根据需求进行配置和定制。以下是一个示例：</p>

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
public class CustomThreadPool {
    public static void main(String[] args) {
        // 创建自定义线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                5, // 核心线程数
                10, // 最大线程数
                1, // 线程空闲时间
                TimeUnit.SECONDS, // 空闲时间单位
                new LinkedBlockingQueue<>(100) // 阻塞队列
        );
        // 提交任务给线程池执行
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            executor.execute(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                try {
                    // 模拟任务执行耗时
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }
        // 关闭线程池
        executor.shutdown();
    }
}
```

<p>在上面的示例中，创建了一个自定义线程池<code>executor</code>，通过指定核心线程数、最大线程数、线程空闲时间以及阻塞队列的类型和容量等参数进行配置。</p>
<p>然后，可以通过调用<code>execute</code>方法将任务提交给线程池执行。每个任务是一个简单的匿名函数，打印任务ID和执行线程的名称，并模拟了一个耗时操作。</p>
<p>最后，通过调用<code>shutdown</code>方法关闭线程池。</p>
<p>自定义线程池时，可以根据具体需求进行配置，例如设置拒绝策略、添加线程池监控等。可以通过<code>ThreadPoolExecutor</code>类的其他构造函数或方法进行更多的配置和定制。</p>
</div></div></div><div class="flex flex-col"><button class="mb-2 transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-300"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795Z"></path></svg></button><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
        </div>
    </div>
</div>

::: details 用例
```java

import java.util.concurrent.*;

/**
 * 自定义线程池
 * 描述：TODO
 * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
 * @创建时间 2022-08-26 11:01
 */
public class MyThreadPool {

    public static ExecutorService threadPool;

//    public static ExecutorService getThreadPool(){
//        if(threadPool==null){
//            newThreadPool();
//        }
//        return threadPool;
//    }
    static {
        newThreadPool();
    }


    /**
     * 1⚫corePoolSize线程池的核心线程数
     *      线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，
     *      除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。
     * 2⚫maximumPoolSize能容纳的最大线程数
     *      一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，
     *      如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，
     *      然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。
     *      线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。
     * 3⚫keepAliveTime空闲线程存活时间
     *      一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，
     *      这里的指定时间由keepAliveTime来设定
     * 4⚫unit 空闲线程存活时间单位
     * 5⚫workQueue 存放提交但未执行任务的队列
     *      新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务。jdk中提供了四种工作队列：
     *      ArrayBlockingQueue
     *      基于数组的有界阻塞队列，按FIFO排序。新任务进来后，会放到该队列的队尾，有界的数组可以防止资源耗尽问题。
     *      当线程池中线程数量达到corePoolSize后，再有新任务进来，则会将任务放入该队列的队尾，等待被调度。
     *      如果队列已经是满的，则创建一个新线程，如果线程数量已经达到maxPoolSize，则会执行拒绝策略。
     *      LinkedBlockingQuene
     *      基于链表的无界阻塞队列（其实最大容量为Interger.MAX），按照FIFO排序。由于该队列的近似无界性，
     *      当线程池中线程数量达到corePoolSize后，再有新任务进来，会一直存入该队列，而不会去创建新线程直到maxPoolSize，
     *      因此使用该工作队列时，参数maxPoolSize其实是不起作用的。
     *      SynchronousQuene
     *      一个不缓存任务的阻塞队列，生产者放入一个任务必须等到消费者取出这个任务。也就是说新任务进来时，不会缓存，
     *      而是直接被调度执行该任务，如果没有可用线程，则创建新线程，如果线程数量达到maxPoolSize，则执行拒绝策略。
     *      PriorityBlockingQueue
     *      具有优先级的无界阻塞队列，优先级通过参数Comparator实现。
     * 6⚫threadFactory 创建线程的工厂类
     *      创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等
     * 7⚫handler 等待队列满后的拒绝策略
     *      当工作队列中的任务已到达最大限制，并且线程池中的线程数量也达到最大限制，这时如果有新任务提交进来，
     *      该如何处理呢。这里的拒绝策略，就是解决这个问题的，jdk中提供了4中拒绝策略：
     *      CallerRunsPolicy
     *      该策略下，在调用者线程中直接执行被拒绝任务的run方法，除非线程池已经shutdown，则直接抛弃任务
     *      AbortPolicy
     *      该策略下，直接丢弃任务，并抛出RejectedExecutionException异常
     *      DiscardPolicy
     *      该策略下，直接丢弃任务，什么都不做
     *      DiscardOldestPolicy
     *      该策略下，抛弃进入队列最早的那个任务，然后尝试把这次拒绝的任务放入队列
     */
    private static void newThreadPool(){
        threadPool = new ThreadPoolExecutor(10,250,
                1L, TimeUnit.SECONDS,
                new LinkedBlockingQueue<>(250),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
    }
}

```
:::

## 自定义注解

<div  class="gpt_html_div">
    <div id="scrollRef" class="h-full overflow-hidden overflow-y-auto">
        <div id="image-wrapper" class="w-full max-w-screen-xl m-auto dark:bg-[#101014] p-4">
            <!--问-->
            <div class="flex w-full mb-6 overflow-hidden flex-row-reverse"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 ml-2"><span class="n-avatar" style="--n-font-size:14px; --n-border:none; --n-border-radius:3px; --n-color:rgba(204, 204, 204, 1); --n-color-modal:rgba(204, 204, 204, 1); --n-color-popover:rgba(204, 204, 204, 1); --n-bezier:cubic-bezier(0.4, 0, 0.2, 1); --n-merged-size:var(--n-avatar-size-override, 34px);"><img loading="eager" src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png" data-image-src="http://lingdu990130556.gitee.io/vuepress-lingdu-v2/img/logo.png"><!----></span></div><div class="overflow-hidden text-sm items-end"><p class="text-xs text-[#b4bbc4] text-right">2023/8/2 11:13:52</p><div class="flex items-end gap-1 mt-2 flex-row-reverse"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#d2f9d1] dark:bg-[#a1dc95]"><div class="leading-relaxed break-words"><div class="whitespace-pre-wrap">自定义注解</div></div></div><div class="flex flex-col"><!----><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
            <!--答-->
            <div class="flex w-full mb-6 overflow-hidden"><div class="flex items-center justify-center flex-shrink-0 h-8 overflow-hidden rounded-full basis-8 mr-2"><span class="text-[28px] dark:text-white"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" aria-hidden="true" width="1em" height="1em"><path d="M29.71,13.09A8.09,8.09,0,0,0,20.34,2.68a8.08,8.08,0,0,0-13.7,2.9A8.08,8.08,0,0,0,2.3,18.9,8,8,0,0,0,3,25.45a8.08,8.08,0,0,0,8.69,3.87,8,8,0,0,0,6,2.68,8.09,8.09,0,0,0,7.7-5.61,8,8,0,0,0,5.33-3.86A8.09,8.09,0,0,0,29.71,13.09Zm-12,16.82a6,6,0,0,1-3.84-1.39l.19-.11,6.37-3.68a1,1,0,0,0,.53-.91v-9l2.69,1.56a.08.08,0,0,1,.05.07v7.44A6,6,0,0,1,17.68,29.91ZM4.8,24.41a6,6,0,0,1-.71-4l.19.11,6.37,3.68a1,1,0,0,0,1,0l7.79-4.49V22.8a.09.09,0,0,1,0,.08L13,26.6A6,6,0,0,1,4.8,24.41ZM3.12,10.53A6,6,0,0,1,6.28,7.9v7.57a1,1,0,0,0,.51.9l7.75,4.47L11.85,22.4a.14.14,0,0,1-.09,0L5.32,18.68a6,6,0,0,1-2.2-8.18Zm22.13,5.14-7.78-4.52L20.16,9.6a.08.08,0,0,1,.09,0l6.44,3.72a6,6,0,0,1-.9,10.81V16.56A1.06,1.06,0,0,0,25.25,15.67Zm2.68-4-.19-.12-6.36-3.7a1,1,0,0,0-1.05,0l-7.78,4.49V9.2a.09.09,0,0,1,0-.09L19,5.4a6,6,0,0,1,8.91,6.21ZM11.08,17.15,8.38,15.6a.14.14,0,0,1-.05-.08V8.1a6,6,0,0,1,9.84-4.61L18,3.6,11.61,7.28a1,1,0,0,0-.53.91ZM12.54,14,16,12l3.47,2v4L16,20l-3.47-2Z" fill="currentColor"></path></svg></span></div><div class="overflow-hidden text-sm items-start"><p class="text-xs text-[#b4bbc4] text-left">2023/8/2 11:15:57</p><div class="flex items-end gap-1 mt-2 flex-row"><div class="text-black text-wrap min-w-[20px] rounded-md px-3 py-2 bg-[#f4f6f8] dark:bg-[#1e1e20]"><div class="leading-relaxed break-words"><div class="markdown-body"><p>自定义注解是一种在Java中用于为程序元素（类、方法、字段等）添加额外元数据的方式。通过自定义注解，可以在编译时或运行时读取和处理这些元数据，从而实现相应的功能。</p>
<p>以下是一个示例，展示如何定义和使用一个自定义注解：</p>

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME) // 注解保留到运行时
@Target(ElementType.METHOD) // 作用于方法
public @interface CustomAnnotation {
    String value() default ""; // 声明一个名为value的成员，默认值为空字符串

    int count() default 1; // 声明一个名为count的成员，默认值为1
}
```

<p>在上述示例中，我们定义了一个<code>CustomAnnotation</code>的自定义注解。通过<code>@interface</code>关键字进行声明，并使用了<code>@Retention</code>和<code>@Target</code>元注解来指定注解的保留策略和作用目标。</p>
<p><code>CustomAnnotation</code>注解定义了两个成员：<code>value</code>和<code>count</code>。其中，<code>value</code>成员使用了默认值为空字符串，<code>count</code>成员使用了默认值为1。你可以根据需要在自定义注解中定义不同类型的成员，并为其设置默认值。</p>
<p>接下来，我们来看一个使用自定义注解的示例：</p>

```java
public class MyClass {
    @CustomAnnotation(value = "Hello", count = 3)
    public void myMethod() {
        System.out.println("Executing myMethod");
}
```

<p>在上述示例中，<code>myMethod</code>方法使用了<code>@CustomAnnotation</code>注解，并为其中的<code>value</code>和<code>count</code>成员提供了具体的值。</p>
<p>在运行时，可以通过反射机制来获取注解信息并进行处理，例如：</p>

```java
import java.lang.reflect.Method;

public class Main {
    public static void main(String[] args) throws NoSuchMethodException {
        MyClass obj = new MyClass();
        Method method = obj.getClass().getMethod("myMethod");
        CustomAnnotation annotation = method.getAnnotation(CustomAnnotation.class);
        if (annotation != null) {
            String value = annotation.value();
            int count = annotation.count();
            System.out.println("Value: " + value);
            System.out.println("Count: " + count);
        }
    }
}
```

<p>在上述示例中，我们通过反射获取了<code>myMethod</code>方法上的<code>CustomAnnotation</code>注解，并获取了其中的成员值。然后，我们可以根据这些注解信息执行相应的处理逻辑。</p>
<p>自定义注解为我们提供了一种扩展Java语言功能的方式，可以通过在代码中添加自定义注解来传递额外的元数据信息，以便在编译时或运行时进行相应的处理。</p>
</div></div></div><div class="flex flex-col"><button class="mb-2 transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-300"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795Z"></path></svg></button><!----><button class="transition text-neutral-300 hover:text-neutral-800 dark:hover:text-neutral-200"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class=" iconify iconify--ri" width="1em" height="1em" viewBox="0 0 24 24"><path fill="currentColor" d="M12 3c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0 14c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Zm0-7c-1.1 0-2 .9-2 2s.9 2 2 2s2-.9 2-2s-.9-2-2-2Z"></path></svg></button><!----></div></div></div></div>
        </div>
    </div>
</div>

::: details 用例
```java
package com.lingdu.common.datasource.annotation;

import com.lingdu.common.datasource.enums.Usage;

import java.lang.annotation.*;

/**
 * 数据源切换
 *
 * @author 99013
 * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
 * @创建时间 2023-04-11 9:12
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DSHandover {
    /**
     * 数据源标识
     *
     * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
     * @创建时间 2023-04-11 9:12
     */
    String value();

    /**
     * 数据源用途
     *
     * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
     * @创建时间 2023-04-11 9:12
     */
    Usage usage() default Usage.RW;

    /**
     * 是否开启事务
     *
     * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
     * @创建时间 2023-04-11 9:39
     */
    boolean transactional() default false;

    /**
     * 是否自动提交事务 true自动提交 false手动提交
     *
     * @作者 <b><a class=b href="https://blog.csdn.net/lingdu_dou" color="red">⭕°</a></b>
     * @创建时间 2023-04-11 9:13
     */
//    boolean autoCommit() default true;
}

```
:::
